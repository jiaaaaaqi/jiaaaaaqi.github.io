<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[node学习笔记-day1]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2Fnode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-day1%2F</url>
    <content type="text"><![CDATA[Node.js简介Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 node适合用来做什么Node.js 可以解析JS代码（没有浏览器安全级别的限制）提供很多系统级别的API，如： 文件的读写 进程的管理 网络通信 …… 启用服务器1234567891011//引包let http = require("http");//创建服务器，参数是一个回调函数，表示如果有请求进来，要做什么let server = http.createServer(function (req, res) &#123; //req表示请求,request;res表示响应,response //设置Http头部，状态码是200，文件类型是html，字符集是utf8 res.writeHead(200, &#123;"Content-type": "text/html;charset=UTF-8"&#125;); res.end("hello,node");&#125;);//运行服务器，监听3000端口（端口号可以任意更改）server.listen(80); 注意事项： 如果想修改程序，必须中断当前运行的服务器，重新node一次，刷新，才行。 Node.js是服务器的程序，写的js语句，都将运行在服务器上。返回给客户的，都是已经处理好的纯html。 ctrl+c，就可以打断挂起的服务器程序。此时按上箭头，能够快速调用最近的node命令 cls可以清屏 我们本地写一个js，不能直接拖入浏览器运行，但是有了node，我们任何一个js文件，都可以通过node来运行。也就是说，node就是一个js的执行环境。 我们现在，要跑起来一个服务器，要以.js存储、用node命令运行这个js文件。 node没有文件夹的概念12345678910111213141516171819// require表示引包，意思是引用自己的一个功能var http = require("http");var fs = require("fs");// 创建服务器，参数是一个回调函数，表示如果有请求进来，要做什么var server = http.createServer(function(req,res)&#123; if(req.url == "/fang")&#123; fs.readFile("./test/xixi.html",function (err,data) &#123; //req表示请求，request;res表示响应,response //设置HTTP头部，状态码是200，文件类型是html，字符集是utf-8 res.writeHead(200,&#123;"Content-type":"text/html;charset=UTF-8"&#125;); res.end(data); &#125;); &#125;else&#123; res.writeHead(404,&#123;"Content-type":"text/html;charset=UTF-8"&#125;); res.end("xixi,没有这个页面呦"); &#125;&#125;);// 运行服务器，监听3030端口（端口号可以自己随便改）server.listen(3030,"127.0.0.1"); 以上代码，运行后浏览器里的结果会是啥？ “xixi,没有这个页面呦” 原因就是在node中没有文件夹的概念 HTTP模块Node.js中，将很多的功能，划分为了一个个node_modules，大陆的书翻译为模块；台湾的书，翻译为模组。这是因为，有一些程序需要使用fs功能（文件读取功能），有一些不用的，所以为了效率，你用什么，你就require什么。官网api:http://nodejs.org/api/ 示例123456789101112// 引用模块var http = require("http");// 创建一个服务器，回调函数表示接收到请求之后做的事情var server = http.createServer(function(req,res)&#123; //req参数表示请求，res表示响应 console.log("服务器接收到了请求"+req.url); //设置头部 res.writeHead(200,&#123;"Content-Type":"text/html;charset=UTF8"&#125;); res.end();&#125;);//监听端口server.listen(2020,"localhost"); 注意： response.end();必写，否则会认为请求没有结束 response.writeHead(200,{“Content-Type”:”text/html;charset=UTF8”});设置一个响应头 编码为utf-8 response.write(“”);内容必须为字符串 URL模块 req.url属性，表示用户的请求URL地址。所有的路由设计，都是通过req.url来实现的。 识别URL，用到两个新模块，第一个就是url模块，第二个就是querystring模块 字符串查询，用querystring处理 1234567querystring.parse('foo=bar&amp;baz=qux&amp;baz=quux&amp;corge')// returns &#123; foo: 'bar', baz: ['qux', 'quux'], corge: '' &#125; fs模块1234567891011121314151617//1. 导入文件系统fs依赖 var fs = require('fs');//2. 读取 // 同步读取 var data = fs.readFileSync('data.txt'); // 打印出来,原生是buffer数据,需要转码 console.log(data.toString()); console.log('结束');// 3.node.js的回调函数// node.js的异步编程的直接体现就是回调函数.// 异步读取var time = new Date();fs.readFile('data.txt', function (err,data) &#123; console.log(data.toString()); console.log('读取本地文件耗时:' + (new Date() - time)+'毫秒');&#125;);console.log('完毕'); 123456readFile();// 读取文件//-&gt;fs.readFile(path,[option],callback)//-&gt;callback函数有两个参数function(err,data)&#123;&#125;//1).err是读取文件失败后出发的错误对象//2).data是从文件中读取的数据. 12345678910111213.writeFile()// 写入文件-&gt;fs.writeFile(path,data,[option],callback)var str = '此情此景,我想吟诗一首!'fs.writeFile('data1.txt', str, function (err) &#123;if (err) &#123; throw err; &#125;console.log('写入成功!');&#125;);//默认的第三个参数是&#123;flag='w'&#125;,是写的操作.会清空掉文件.如果想要追加内容,可以设置&#123;flag='a'&#125;fs.writeFile('data1.txt', str,&#123;flag:'a'&#125;, function (err) &#123;if (err) &#123;throw err;&#125;console.log('写入成功!');&#125;);//&#123;flag:'w'&#125;为默认值,w代表写文件,a代表追加内容 // 今天先到这吧 眼睛痛]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F%E9%9A%8F%E7%AC%94%2Fhello-world%2F</url>
    <content type="text"><![CDATA[最近几周开始接触了git和GitHub,偶然看到可以用GitHub提供的pages服务基于Hexo免费搭建个人博客，周末闲来无事就看着Hexo的官方文档自己搭了一个。虽然步骤不多，也不麻烦，但是还是碰到了许多问题，还好有万能的度娘，每当我迷失方向时总会指引我走出迷途。 ​ 下面先写一下通过Hexo创建文章时的几条常用命令，以后闲了的话会把我搭建博客配置各种东西的步骤完整的总结出来。 基本操作执行下列命令来创建一篇新文章。1$ hexo new "My New Post" More info: 写作 开启本地服务器1$ hexo server More info: Server 生成文件1$ hexo generate More info: Generating 部署1$ hexo deploy More info: Deployment 监视文件变动Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。 1$ hexo generate --watch 完成后部署可以执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。 12$ hexo generate --deploy$ hexo deploy --generate 简写123# 上面两个命令可以简写为$ hexo g -d$ hexo d -g]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
